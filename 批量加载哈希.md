分批把哈希批量加载进 hashcat，就能充分利用 GPU 的并行能力，大幅压缩总时间。
只用密码掩码： ?a?a?a?a?a?a
只破解私钥密码
我使用Windows11操作系统。
cpu：12900k
GPU:RTX 3080


下面给你一套**在 Windows 11 + RTX 3080 环境下，用掩码 `?a?a?a?a?a?a`（6 位任意可打印字符）批量跑 JKS 私钥口令**的实战方案，包括：

1. **为什么“批量加载哈希”≈一次全吃**
2. 掩码空间与预估耗时
3. 利用 `--skip/--limit` 把巨大掩码切片并自动跑完
4. 完整 PowerShell 脚本（可直接粘贴）

---

## 1  批量加载哈希：一次性喂给 hashcat

* **模式 15500** 的内核几乎不受“行数”限制；
* 10 万行 `$jksprivk$…` 只占 ~12 MiB RAM；3080 显存轻松放得下；
* 因为 GPU 在线程束里并行计算，不存在“每行 10 秒”这回事。

  **结论：** 把所有私钥哈希一次性塞进同一个文件，让 GPU 同时算，才是最快。

```bash
# 假设已由 JksPrivkPrepare.jar 生成
D:\hashcat\jks_hashes_all.txt   # 100 000 行
```

运行时只需  **一行命令** ，不用分批加载哈希本身。

---

## 2  掩码空间 vs 耗时

| 自定义字符集       | 单位字符数 | 总组合数 (6 位)                | 3080 速率 10 k H/s 时耗时 |
| ------------------ | ---------- | ------------------------------ | ------------------------- |
| `?a`（95 ASCII） | 95         | 95⁶ =**7.35 × 10¹¹** | **≈ 851 天**       |
| `?u?l?d`（62）   | 62         | 5.68 × 10¹⁰                 | 66 天                     |
| `?l?d`（36）     | 36         | 2.18 × 10⁹                   | 2.5 天                    |
| `?l`（26）       | 26         | 3.09 × 10⁸                   | 8.6 小时                  |

> * `?a?a?a?a?a?a` 的完整空间对单卡来说  **不可行** （>2 年）。
> * **建议** ：根据实际口令习惯自定义字符集，如 `-1 ?l?d?s` → 39 字符。
> * 可先跑常见规则/字典，再逐渐扩大掩码空间。

---

## 3  用 `--skip/--limit` 把巨型掩码切片

hashcat 可以对同一掩码做 **分段跑** ，互不重叠，便于多机/多进程并行，也能让单机批量自动续跑。

* **总 keyspace** ：

```bash
  hashcat --keyspace -m 15500 -a 3 -1 ?a ?1?1?1?1?1?1
```

  输出一个整数 `K`（例如 7.35e11）。

* **切片公式** ：每次跑 `--limit=N`。常用 `N = 50_000_000`（五千万）左右，单片耗时 ≈ 1.5 小时。

示例命令（第一片，跳过 0）：

```bash
hashcat -m 15500 -a 3 -O -w 4 `
  --session=jks_mask `
  --status --status-timer=60 `
  --skip=0 --limit=50000000 `
  jks_hashes_all.txt -1 ?a ?1?1?1?1?1?1
```

第二片把 `--skip` 改成 50 000 000，依此类推。

可脚本自动循环直到 `skip + limit ≥ keyspace`。

---

## 4  一键 PowerShell 脚本

> 把下面代码存成 `run_jks_mask.ps1`，调整路径后运行即可。脚本会按片大小循环跑完全部 keyspace，并在破解成功时自动停止。

```powershell
# --- 配置区 ----------------------------------------------------------
$HashcatExe   = "D:\hashcat\hashcat.exe"
$Hashes       = "D:\hashcat\jks_hashes_all.txt"
$Session      = "jks_mask"
$ChunkSize    = 50000000          # 每片 5e7 组合
$Custom1      = "?a"              # 自定义字符集 1
$Mask         = "?1?1?1?1?1?1"    # 6 位掩码
$Params       = "-m 15500 -a 3 -O -w 4 --status --status-timer=60"
# ---------------------------------------------------------------------

# 计算总 keyspace
$keyspace = & $HashcatExe --keyspace -a 3 "-1" $Custom1 $Mask
Write-Host "`n[*] Total keyspace: $keyspace"

for ($skip=0; $skip -lt $keyspace; $skip += $ChunkSize) {
    $limit = [Math]::Min($ChunkSize, $keyspace - $skip)
    Write-Host "`n=== Running chunk: skip=$skip limit=$limit ===`n"

    & $HashcatExe $Params `
        --session=$Session `
        --skip=$skip --limit=$limit `
        "-1" $Custom1 `
        $Hashes $Mask

    if ($LASTEXITCODE -eq 0) {
        Write-Host ">> 密码已全部破解或找到至少一个结果，脚本退出。"
        break
    }
}
```

 **用法** ：

```powershell
powershell -ExecutionPolicy Bypass -File run_jks_mask.ps1
```

* 每完成一片，hashcat 会把已破解的口令写入 `hashcat.potfile`，脚本检测退出码 `0` 可自动停机。
* 若中途中断，可用 `--restore` 继续；或直接重跑脚本，它会跳到正确的下一片。

---

### 关键提示

1. **掩码越大，时间越爆炸** 。先缩字符集、再切片并行。
2. 3080 单卡模式 15500 极限约 10–12 k H/s；速度受温度、电源、驱动影响。
3. 确保 `hashcat -I` 能识别 GPU；否则只会掉到 CPU ≈ 1 H/s。
4. 多机并行时，用不同 `--skip/--limit` 切片范围即可，`--potfile-path` 指向共享目录避免重复计算。

祝你顺利拿下 10 万份私钥口令！
